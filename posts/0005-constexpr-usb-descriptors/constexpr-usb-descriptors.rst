.. rstblog-settings::
   :title: Writing reusable USB device descriptors (and other constant data) with C++ constexpr
   :url: constexpr-usb-descriptors
   :date: 2 January 2026
   :tags: arm-programming, c, hardware, usb, usb-descriptor


Several years ago I wrote `a post
</2019/12/27/writing-reusable-usb-device-descriptors-with-some-xml-python-and-c>`_
which introduced my method of declaring XML comments in my source code and
scanning them with a Python script to produce a generated byte array. I've used
this several times over the years and as tends to happen, I now hate it. My
biggest pet peeve has turned out to be its lack of flexibility. Every time I
want to do something crazy, like create HID reports or add extensive audio
descriptors (with their relatively complicated cross-referencing scheme), I end
up having to make big changes to my Python. It just isn't simple enough! The
other thing is that it's not very portable either. If have some hardware that,
for example, locks endpoint addresses to specific endpoint instances (a
restriction that the STM32 USB peripheral doesn't have, but the SAMD21 does),
it'll be yet another modification to the script.

I'd like to introduce in this post a fluent API written entirely using C++
``constexpr`` which enables a syntax like this:

.. code-block:: c++

    constexpr auto kHidEndpointIn = usb::EndpointDescriptor()
                                        .EndpointAddress(0x81)
                                        .Attributes(0x03)
                                        .MaxPacketSize(64)
                                        .Interval(1);
    constexpr auto kHidEndpointOut = usb::EndpointDescriptor()
                                         .EndpointAddress(0x01)
                                         .EndpointAddress(0x01)
                                         .Attributes(0x03)
                                         .MaxPacketSize(64)
                                         .Interval(1);

    constexpr auto kConfigDescriptor =
        usb::ConfigurationDescriptor(0)
            .ConfigurationValue(1)
            .Attributes(0x80)
            .WithInterface(
                usb::InterfaceDescriptor()
                    .InterfaceClass(0x03)
                    .InterfaceSubClass(0x00)
                    .WithEndpoint(kHidEndpointIn)
                    .WithEndpoint(kHidEndpointOut));

To produce something like this in the ``.rodata`` section of my executable:

.. code-block:: text

    000014e1 <_ZL17kConfigDescriptor>:
        14e1:	00290209 	eoreq	r0, r9, r9, lsl #4
        14e5:	80000101 	andhi	r0, r0, r1, lsl #2
        14e9:	00040900 	andeq	r0, r4, r0, lsl #18
        14ed:	00030200 	andeq	r0, r3, r0, lsl #4
        14f1:	21090000 	mrscs	r0, (UNDEF: 9)
        14f5:	01000111 	tsteq	r0, r1, lsl r1
        14f9:	07001922 	streq	r1, [r0, -r2, lsr #18]
        14fd:	40038105 	andmi	r8, r3, r5, lsl #2
        1501:	05070100 	streq	r0, [r7, #-256]	@ 0xffffff00
        1505:	00400301 	subeq	r0, r0, r1, lsl #6
        1509:	00000001 	andeq	r0, r0, r1

Now, I'm not a C++ expert by any means. I'm almost certain I did things in a
harder way than necessary. But my hope is that by telling my journey in getting
to this point someone might find some benefit.

Continue on to read more!

.. rstblog-break::

.. contents::

################################################################################
Motivation
################################################################################

Although it's been well over a decade, I'm still enamoured by USB. I enjoy
writing device-side drivers and coming up with new ways to express simply the
complexities of USB. A constant thorn in my side has been the descriptors.
Starting from the VUSB driver and continuing with my "Teensy" phase, I used
hand-composed arrays of ``uint8_t`` to encode descriptors. I soon tired of this
and moved on to my XML-based method detailed in my post from 7 years ago. This
worked well for a while, but I just had this "itch" in the back of my mind that
there was a better way to do this. Something that would let me express the
descriptors natively in the language I was using and that was more maintainable
than a massive single-file Python XML ETL script.

At this point I should mention that I spent 2022-2024 exploring writing
firmware in Rust. Perhaps I'll write a post about that adventure at some point,
but suffice to say I got frustrated by the fact that returning ``-> impl
Future`` in a trait is not object-safe and the workaround of using ``-> Box<dyn
Future>`` requires using the heap which I'm staunchly against in embedded
programming. But that's a rant for another day. I mention Rust because I came
across `usb-device's DesriptorWriter
<https://docs.rs/usb-device/0.3.2/usb_device/descriptor/struct.DescriptorWriter.html>`_
and became more convinced that there should be a way to express, within the
language, the contents of a descriptor and have it generate for me a blob
containing it. I wasn't a huge fan of the usb-device crate's implementation
since it ends up writing the descriptor to a fixed-size ram-based buffer which
sounds wasteful, but the concept of having an API which generates the
descriptors really sounded enticing.

I focus a lot on putting descriptors in the flash directly, but it's worth
noting that it's perfectly valid to generate descriptors on-the-fly like the
``usb-device`` crate did. The main issue I have is that I think it ends up
being less flash space to simply express the entire descriptor directly as data
rather than expressing the instructions that produce the descriptor. There is
not a lot of "wasted space" in descriptors. On the other hand, perhaps I'm just
stuck on the VUSB/"Teensy" philosophy which expressed the descriptors as blobs
in the flash data. Creating a descriptor dynamically has its benefits, such as
allowing a device to dynamically describe some configuration without requiring
every possible configuration to be described at compile-time.

**********************************************************************
C++ in embedded applications
**********************************************************************

This seems to be a point of controversy still, even in 2025. I decided to use
C++ mainly because RAII, lambdas, and other near-zero-cost abstractions
available in C++ seemed to me to be a great way to write expressive, concise,
and maintainable code that a modern compiler would be more capable of
optimizing. I don't write a lot of microcontroller firmware at work, but when I
do I've used almost exclusively C++.

Many of the "cons" brought up in articles I read about C++ in embedded systems
mention things like dynamic dispatch, heap allocations, exceptions, etc. as
reasons not to use C++. And I agree! I just simply avoid using these features
(although, I think dynamic dispatch has its place and a ``vtable`` is not that
big of an overhead as long as you're careful to keep the call out of hot
loops).

Truth be told, I'd rather be using Rust, but here we are.

################################################################################
Recommended Pre-reading
################################################################################

USB is not a simple topic. If you're unfamiliar or just getting started with
USB I have found the following two websites to be extremely useful:

* USB Made Simple (now defunct, see `the web archive
  <https://web.archive.org/web/20250415152420/http://www.usbmadesimple.co.uk/>`_.
* `Beyond Logic's USB In A Nutshell
  <https://www.beyondlogic.org/usbnutshell/usb1.shtml>`_.

I've read both of these sites probably dozens of times at this point. I've also
become less intimidated by specifications the last decade or so and I'd
recommend reading the USB 2.0 specification (and perhaps the HID and Audio
class specifications) for a bit of "light" reading: `USB-IF Document Library
<https://www.usb.org/documents>`).

In this article I'll be talking about USB descriptors and assuming that the
reader has general knowledge of USB Setup Requests, particular the
GET_DESCRIPTOR request and the USB enumeration process in general.

################################################################################
Program Sections
################################################################################

For the uninitiated, programs for flash-based microcontrollers (and indeed most
programs, at least on Linux) have their contents typically segmented into 3
different sections:

* ``.text``: This contains the executable program instructions
* ``.data``/``.bss``: This contains the variables for the program. The
  ``.data`` section typically has compile-time initialized values whereas the
  ``.bss`` (Block Starting Symbol) section has uninitialized or zero-initialized
  variables.
* ``.rodata``: This contains read-only non-executable data for the program.

The ``.text``, ``.data``, and ``.rodata`` sections (along with a few others)
are included in the final flash data programmed to the microcontroller. When a
microcontroller boots, it usually starts off by reading a specific address in
the flash to establish where the program entry point (or "reset vector" lives).
While we traditionally think of programs starting in ``main``, there's actually
a bunch of startup/initialization that has to happen before ``main`` runs. In
particular, the startup code on a microcontroller consists of 3 primary
responsibilities:

1. Copy the ``.data`` segment from the read-only flash into the appropriate
   location within the microcontroller SRAM. While the initial values for
   ``.data`` are stored in the flash, the program itself is compiled against
   these variables being placed in the SRAM address region. The setting of
   these values in SRAM doesn't happen automatically: the initialization code
   takes care of this.

2. Zero out the ``.bss`` segment in the SRAM. These variables need to be
   initialized to zero. We could have stored these variables in ``.data``, but
   it's wasteful to just store a bunch of zeroes in the flash just to copy them
   into the RAM when we could have just noted which addresses in the ram need
   to be zeroed.

3. Execute static constructors and other initialization functions. There's a
   list of function pointers in a ``.init`` section (treated similarly to
   ``.rodata`` with its placement in the flash) which should be called prior to
   ``main`` starting.

After doing these things and perhaps some initial configuration of peripherals
or clocking, the program will finally call the ``main`` function.

.. note:: There are some specific cases where program instructions can end up
   in SRAM, copied there from the flash in a similar manner to ``.data``. When
   I've done this I've usually just straight-up included those functions in
   ``.data`` and then called them normally, but in more security-concious
   systems these kinds of functions might be added to a different segment in
   order to ensure they're located somewhere in the memory space properly
   marked for execution. So there might be more to the initialization phase
   than I've alluded to here.

On most microcontrollers, there is considerably more flash than SRAM. So our
objective is to try and make as much of this constant data like USB descriptors
live in the ``.rodata`` segment: This segment is placed in the flash like the
``.data`` segment, but rather than being copied into the SRAM before use, the
program is compiled against these variables at their address within the flash.
This saves on the SRAM usage and leaves it for data that actually has to change
at runtime.

################################################################################
constexpr
################################################################################

In C++11, the ``constexpr`` keyword was introduced. When placed on a function,
this keyword notes that a function could potentially be executed at
compile-time and puts restrictions on what the function can do in order to
allow the compiler to achieve that. If the function is called in a context that
allows the compiler to derive all the prerequisites for executing the function,
it can also derive the result. This also means that ``constexpr`` functions are
implicitly ``inline`` and the definition of the function needs to be present
with its declaration in order to allow the compiler to evaluate it at
compile-time. When placed on a variable declaration, ``constexpr`` instructs
the compiler to require that the variable (which is now also implicitly
``const``) have a value precomputed at compile-time rather than having a
runtime constructor that runs during program initialization.

.. note::
   :class: alert alert-info

   It's worth mentioning that C++20 introduced the ``constinit`` keyword
   which requires that a variable's value be known and computed at
   compile-time, but the value itself isn't treated as ``const``. I didn't use
   that here, but it's worth noting.

.. note::
   :class: alert alert-info

   In C++14, the allowable control structures within a ``constexpr``
   function were expanded to include ``for``, ``while``, and other such things.

With the above said, I have noticed that sometimes even a
``constexpr``-decorated variable ends up being placed in the ``.data`` section
rather than ``.rodata``. I'm not entirely sure what causes this, though it
tended to coincide with more complex types being stored within the target type
or using an address of something that the compiler has trouble determining at
compile-time in calling the ``constexpr`` function. But, sometimes the compiler
would complain about using non-``constexpr`` values in ``constexpr`` contexts,
so I'm really not sure.

**********************************************************************
Using a struct/class to represent descriptor information
**********************************************************************

I started out pretty simply with defining structs for descriptors like this:

.. code-block:: c++

    struct __attribute__((packed)) DeviceDescriptor {
      static constexpr uint8_t kType = 1;
      uint8_t bLength;
      uint8_t bDescriptorType = kType;
      uint16_t bcdUSB = 0x0200;
      uint8_t bDeviceClass = 0;
      uint8_t bDeviceSubClass = 0;
      uint8_t bDeviceProtocol = 0;
      uint8_t bMaxPacketSize0 = 8;
      uint16_t idVendor = 0x0;
      uint16_t idProduct = 0x0;
      uint16_t bcdDevice = 0x0;
      uint8_t iManufacturer = 0;
      uint8_t iProduct = 0;
      uint8_t iSerialNumber = 0;
      uint8_t bNumConfigurations = 0;
    };

This example struct contains all the data for a USB Device Descriptor and uses
the ``((packed))`` attribute (a.k.a ``#pragma pack``) to remove space between
the data members of the struct. This ensures that the layout as-specified in
the struct matches exactly the descriptor specification.

I then defined an API like this:

.. code-block:: c++

    struct __attribute__((packed)) DeviceDescriptor {
    ...
      constexpr DeviceDescriptor() : bLength(sizeof(DeviceDescriptor)) {}

      constexpr auto& DeviceClass(uint8_t c) {
        bDeviceClass = c;
        return *this;
      }
      constexpr auto& DeviceSubclass(uint8_t c) {
        bDeviceSubClass = c;
        return *this;
      }
      constexpr auto& DeviceProtocol(uint8_t c) {
        bDeviceProtocol = c;
        return *this;
      }
      constexpr auto& MaxPacketSize(uint8_t c) {
        bMaxPacketSize0 = c;
        return *this;
      }
      constexpr auto& VendorProduct(uint16_t v, uint16_t p) {
        idVendor = v;
        idProduct = p;
        return *this;
      }
      constexpr auto& DeviceVersion(uint16_t v) {
        bcdDevice = v;
        return *this;
      }
    ...
    };

This allows me to use the struct in a builder pattern to define the contents
in a single statement during initialization:

.. code-block:: c++

    constexpr auto kDeviceDescriptor = usb::DeviceDescriptor()
                                           .MaxPacketSize(64)
                                           .VendorProduct(0x16c0, 0x05dc)
                                           .DeviceVersion(0x0001);

**********************************************************************
Variable-length descriptors
**********************************************************************

So the above is fine for descriptors whose length is known in advance, but
what about descriptors that are made up of multiple descriptors sent in a
single transfer? The configuration descriptor is one example of this:

.. code-block:: c++

    struct __attribute__((packed)) ConfigurationDescriptorData {
      static constexpr uint8_t kType = 2;
      uint8_t bLength;
      uint8_t bDescriptorType = kType;
      uint16_t wTotalLength = 0;
      uint8_t bNumInterfaces = 0;
      uint8_t bConfigurationValue = 0;
      uint8_t iConfiguration = 0;
      uint8_t bmAttributes = 0;
      uint8_t bMaxPower = 0;

      constexpr ConfigurationDescriptorData()
          : bLength(...), wTotalLength(...) {}
    };

In USB, a configuration typically consists of one or more ``Interface``
instances which consist of one or more ``Endpoint`` instances. For some classes
of USB devices there are also extra descriptors included as well. When the host
requests a configuration descriptor, it starts out by requesting the first 9
bytes of the configuration descriptor (shown above). This covers just the
configuration descriptor itself, which contains the ``wTotalLength`` member.
This gives a total length of the concatenated descriptors that form the
configuration descriptor. Using this information, the host can then request the
full descriptor.

This presents something of a challenge: We need to create a data structure
which can store the information for multiple descriptors, without the length
known in advance. Using ``template`` is the obvious choice, as that's the only
canonical way in C++ to create a structure whose size can vary. The question is
how exactly to form these template.

My first attempt at this was using variadic templates (i.e. templates with an
unbounded number of arguments, ``template <typename T, typename... Trest>``)
and using either inheritance or member declarations to store the sub-descriptors.
The idea was something like this:

.. code-block:: c++

   template<typename T, typename... Trest>
   struct __attribute__((packed)) ExtendableDescriptor : ExtendableDescriptor<Trest...> {
     ...

     template<typename M>
     constexpr ExtendableDescriptor<M, T, Trest...> AddDescriptor(M other) {
       ...
     }
   };

This inheritance-based scheme ran into compilation issues which I never fully
figured out. Again, I'm not a C++ expert. It also ended up with an API that I
wasn't too fond of where I end up having to wrap the whole descriptor
collection in a container, which isn't exactly what I was going for. I also
suspect that it would run into packing issues as ``__attribute__((packed))`` by
definition only applies to the current class, not its ancestors (otherwise, the
ancestors would have an inconsistent memory layout if they weren't packed
normally).

I moved on to something that feels hackier, but actually works and results in
the API that I wanted:

.. code-block:: c++

    template<size_t N, typename Data>
    struct __attribute__((packed)) ExtendableDescriptor : public Data {
      std::array<std::byte, N> others;

      constexpr ExtendableDescriptor() : Data() {}

      // Constructor from a smaller descriptor, appending a new sub-descriptor
      //
      // The caller must ensure that N is appropriately sized to contain both the
      // smaller descriptor's data and the new sub-descriptor.
      template <size_t M, typename T>
      constexpr ExtendableDescriptor(const ExtendableDescriptor<M, Data>& other,
                                     T t)
          : Data(other) {
        static_assert(N > M, "Cannot shrink a descriptor");
        // Use sizeof(T) so that it's trivially copyable for bit_cast
        std::array<std::byte, sizeof(T)> arr =
            std::bit_cast<std::array<std::byte, sizeof(T)>>(t);
        for (size_t i = 0; i < M; i++) {
          others[i] = other.others[i];
        }
        // Trust that N-M covers the correct number of bytes of T (it will
        // generally be less than sizeof(T).
        for (size_t i = M; i < N; i++) {
          others[i] = arr[i - M];
        }
      }
    };

The idea behind this method is that the descriptor inherits from some "Data"
class which is meant to be the parent/top-level descriptor and can be grown by
``bit_cast``-ing the child descriptors into end of the byte array. What this
does is (in a constexpr-safe manner) take each non-padding byte of T and map it
to a value in the array. So long as the Data class is also packed, we shouldn't
run into padding issues and the descriptors should end up consecutive. Here is
an example of using this with the configuration descriptor:

.. code-block:: c++

    template <size_t N = 0>
    class __attribute__((packed)) ConfigurationDescriptor
        : public ExtendableDescriptor<N, ConfigurationDescriptorData> {
      using Base = ExtendableDescriptor<N, ConfigurationDescriptorData>;

     public:
      // Constructor for an empty configuration. Configurations require an index.
      constexpr ConfigurationDescriptor(uint8_t index) : Base(index) {}

      template <size_t M, typename T>
      constexpr ConfigurationDescriptor(const ConfigurationDescriptor<M>& other,
                                        T t)
          : Base(other, t) {}

      // Adds an interface
      template <typename T>
      constexpr auto WithInterface(T t) {
        auto other = ConfigurationDescriptor<T::Size() + T::ExtendedSize() +
                                             Base::ExtendedSize()>(*this, t);
        other.wTotalLength =
            decltype(other)::Size() + decltype(other)::ExtendedSize();
        other.bNumInterfaces += 1;
        return other;
      }
    };

The ``WithInterface`` method is where the magic happens. It takes in some type
which is assumed to be an interface descriptor. Through the magic of template
argument deduction, the actual invocation of this method doesn't require any
``<>`` and can just take in the argument of the descriptor. The method then
constructs a new expanded descriptor based on the current descriptor, passes in
the new descriptor, and then modifies the appropriate fields of the
parent/top-level descriptor to keep things coherent. In this case, the
``wTotalLength`` is incremented by the length of the new descriptor and
``bNumInterfaces`` is incremented by 1.

The other thing to note here is the default value on the ``size_t`` parameter:
It's valid to have a descriptor that has 0 bytes of other descriptors. This is
one of main benefits of using ``std::array`` to hold the data array: It's valid
to have a 0-sized ``std::array`` whereas a standard C-array can't have a size
of 0. By starting a descriptor off at 0 (and making it the default), we end up with a very
ergonomic (in my opinion) API:

.. code-block:: c++

    constexpr auto kConfigDescriptor =
        usb::ConfigurationDescriptor()
            .ConfigurationValue(1)
            .Attributes(0x80)
            .WithInterface(...);

**********************************************************************
Descriptor Sizing
**********************************************************************

At this point, I need to discuss how I deal with descriptor lengths. Above you
might have noticed the subtle detail of setting the ``DeviceDescriptor``'s
``bLength`` member with ``sizeof(DeviceDescriptor)``. While this works for that
case, it breaks down badly for extendable descriptors. Typically, the
``bLength`` member of a descriptor refers only to the length of that descriptor
itself, **not including** any appended descriptors. That means that using
``sizeof`` on an ``ExtendableDescriptor`` is not tenable.

To manage this situation, I ended up defining a simple class which provides a
static function declaring some number which is meant to be used as the ``bLength``
value:

.. code-block:: c++

    template <size_t N>
    struct __attribute__((packed)) DescriptorSize {
      static constexpr size_t Size() { return N; }
      static constexpr size_t ExtendedSize() { return 0; }
    };

Now, descriptors simply need to inherit from ``DescriptorSize`` and they'll
usable in a few convenient situations:

.. code-block:: c++

    struct __attribute__((packed)) ConfigurationDescriptorData
        : public DescriptorSize<9> {
      ...
      uint8_t bLength;
      ...
      uint16_t wTotalLength;
      ...

      // Now bLength and wTotalLength can default to the explicitly defined
      // descriptor size!
      constexpr ConfigurationDescriptorData()
          : bLength(Size()), wTotalLength(Size()) {}
    };

    // The extendable descriptor can "override" (well, name-hide or "shadow")
    // the ExtendedSize member so that it returns an appropriate value.
    template <size_t N, typename Data>
    class __attribute__((packed)) ExtendableDescriptor : public Data {
     public:
      // This hides the version from DescriptorSize (presumably, Data inherits
      // from that)
      static constexpr size_t ExtendedSize() { return N; }
      ...
    };

    // We can also appropriately-size the return type of functions that expand
    // the descriptor!
    struct ConfigurationDescriptor ... {
      ...
      template <typename T>
      constexpr auto WithInterface(T t) {
        auto other = ConfigurationDescriptor<T::Size() + T::ExtendedSize() +
                                             Base::ExtendedSize()>(*this, t);
        other.wTotalLength =
            decltype(other)::Size() + decltype(other)::ExtendedSize();
        ...
      }
    };

So that covers ``bLength``, but ``wTotalLength`` is still an issue. Above you
can see that we're using the ``ExtendedSize`` function to set ``wTotalLength``
along with ensuring the new descriptor is large enough to contain the appended
interface descriptor. In this situation, we simply wanted to expand the
descriptor by the size of the appended descriptor and ensure ``wTotalLength``
is incremented accordingly. Why then did we not use ``sizeof`` here? The issue
is twofold:

* **Padding:** While ``__attribute__((packed))`` guarantees that no additional
  padding bytes are placed between members for alignment, it *seems* to still
  be possible that trailing padding bytes may appear at the end of a class. I
  had this happen once. Maybe I made a typo and forgot ``((packed))`` in a
  class? Or maybe I ran into the next issue and it spiraled into this issue as
  well.

* **Metadata members:** This isn't something I've introduced yet in this
  article (keep reading!), but in certain situations it's very convenient to
  have extra information about the descriptor that might be useful for the
  program to use as a constant, but shouldn't be included in the data sent with
  the descriptor. This data can be placed in a position where the ``bit_cast``
  doesn't pick it up and include it in the expandable byte array.

The ``ExtendedSize`` function is therefore defined to be the additional bytes
in the descriptor which contribute to its USB-facing payload. Summing ``Size``
and ``ExtendedSize`` gives the total length of the descriptor. We therefore
augment the ``ExtendableDescriptor`` like so to make that work:

.. code-block:: c++

    // The extendable descriptor can "override" (well, name-hide or "shadow")
    // the ExtendedSize member so that it returns an appropriate value.
    template <size_t N, typename Data>
    class __attribute__((packed)) ExtendableDescriptor : public Data {
     public:
      // This hides the version from DescriptorSize (presumably, Data inherits
      // from that)
      static constexpr size_t ExtendedSize() { return N; }
      ...
    };

We've now fully decoupled the size of the class from the size of the
descriptor. And done so in a way that is still ``constexpr``-safe!

**********************************************************************
Descriptor "Tagging" or Metadata
**********************************************************************

I mentioned earlier that decoupling the total length of a descriptor from
``sizeof`` enables "metadata" members of descriptors, or data on a descriptor
that doesn't constitute part of its payload. Consider the case of an HID (Human
Interface Device) report descriptor: These descriptors are referenced in the
HID descriptor that's included with the configuration/interface descriptor so
that the host is made aware of their presence. That reference can itself be
considered a descriptor:

.. code-block:: c++

    // HID report descriptors are declared in the HID descriptor. This represents
    // the entry in that descriptor for a given report descriptor.
    struct __attribute__((packed)) HidReportDescriptorTag
        : public DescriptorSize<3> {
      uint8_t bDescriptorType = HidReportDescriptorData::kType;
      uint16_t wDescriptorLength;

      constexpr HidReportDescriptorTag(uint16_t length)
          : wDescriptorLength(length) {}
    };

When declaring a report descriptor, it'd be nice if this tag was automatically
created so that it doesn't have to be manually hardcoded. This is
straightforwardly done by simply declaring an additional data member in the
``ExtendableDescriptor`` child class ``HidReportDescriptor``:

.. code-block:: c++

    // HID report descriptor builder
    template <size_t N = 0>
    class __attribute__((packed)) HidReportDescriptor
        : public ExtendableDescriptor<N, HidReportDescriptorData> {
      using Base = ExtendableDescriptor<N, HidReportDescriptorData>;

     public:
      // This tag is used in the HID descriptor to reference this descriptor
      HidReportDescriptorTag hid_tag;

      constexpr HidReportDescriptor()
          : Base(), hid_tag(Base::Size() + Base::ExtendedSize()) {}
      template <size_t M, typename T>
      constexpr HidReportDescriptor(const HidReportDescriptor<M>& other, T t)
          : Base(other, t), hid_tag(Base::Size() + Base::ExtendedSize()) {}

    ...
    };

Since the data for parent classes is ordered before the data for child classes,
we're assured that this ``hid_tag`` member is not going to be copied during the
``bit_cast`` operation that copies the contents of the
``ExtendableDescriptor``'s array and we're assurred that it's not going to get
caught in the ``ExpandedSize`` bytes which are included in the USB payload. The
main thing we need to cover then is ensuring that the tag is set correctly when
it's constructed each time. This is straightforwardly done by setting a default
"base case" value in the default constructor and then making sure to also
initialize it in the constructor invoked when expanding the descriptor. It's
worth noting that so long as you don't have a default constructor for the tag
type, the compiler will actually bark at you if you forget to initialize the
value: ``constexpr`` requires that everything be explicitly initialized!

We can now use this tag when declaring a descriptor that requires the
information:

.. code-block:: c++

    constexpr auto kHidReport =
        usb::hid::HidReportDescriptor()
            .UsagePage16(0xFF00)  // Vendor
            .Usage(0x1)
            .Collection(0x1)  // Application
            ...
            .EndCollection();

    constexpr auto kConfigDescriptor =
        usb::ConfigurationDescriptor(0)
            .ConfigurationValue(1)
            .Attributes(0x80)
            .WithInterface(
                usb::InterfaceDescriptor()
                    .InterfaceClass(0x03)
                    .InterfaceSubClass(0x00)
                    .WithDescriptor(usb::hid::HidDescriptor().IncludeReport(
                        kHidReport.hid_tag)) // <-- Just reference it!
                    ...
            );

################################################################################
Creating a distributed descriptor lookup table
################################################################################

Now that we can use ``constexpr`` to define our descriptors and they can be
stored as constants, we need to provide a way for the descriptors to be used.
While we can hardcode the association between the ``GET_DESCRIPTOR`` requests
and the particular report to return (and many USB device implementations do
this), I continue to be enamored by the pattern from the "Teensy" codebase
where a table was declared which is then searched dynamically when a setup
request arrives. It's small and code-efficient!

In the past, I've declared this table as a straight-up array. Here's an example
from my old codegen:

.. code-block:: c

    const USBDescriptorEntry usb_descriptors[] = {
      { 0x0100, 0x0000, sizeof(device), device },
      { 0x0300, 0x0000, sizeof(lang), lang },
      { 0x0301, 0x0409, sizeof(manufacturer), manufacturer },
      { 0x0302, 0x0409, sizeof(product), product },
      { 0x0200, 0x0000, sizeof(configuration), configuration },
      { 0x2200, 0x0002, sizeof(hid_report), hid_report },
      { 0x0000, 0x0000, 0x00, NULL }
    };

When a ``GET_DESCRIPTOR`` request arrives, the ``usb_descriptors`` array will
be traversed until the "null" entry at the end is reached or the requested
descriptor is found. My main problem with this method is that the descriptor
table ends up needing to be centrally located: I can have one and only one
table, and it has to include all the descriptors for the project.

In an ideal world, I should be able to add a USB descriptor anywhere in my
codebase and have it included automatically in this table. In this
implementation, I've accomplished this by way of a specially named code
section. Firstly, here's how I've defined the descriptor entry:

.. code-block:: c++

    struct _DescriptorTableEntry {
      const void* ptr;
      size_t length;
      union {
        uint16_t wValue;
        struct {
          uint8_t index;  // LSByte I hope
          uint8_t type;   // MSByte I hope
        } type_index;
      };
      uint16_t wIndex;

      constexpr _DescriptorTableEntry()
          : ptr(nullptr), length(0), wValue(0), wIndex(0) {}

      template <typename T>
      constexpr _DescriptorTableEntry(const T& desc)
          : ptr(&desc),
            length(T::Size() + T::ExtendedSize()),
            type_index{desc.tag.index, T::kType},
            wIndex(desc.tag.wIndex) {}

      static bool Find(uint16_t wValue, uint16_t wIndex, const void*& ptr,
                       size_t& length);
    };
    #define USB_DESCRIPTOR(desc)                                                \
      constexpr __attribute__((                                                 \
          used, section(".rodata.keep.usbdescbbb"))) usb::_DescriptorTableEntry \
      desc##Entry(desc)

This causes each table entry to be linked into a section called
``.rodata.keep.usbdescbbb``. There's nothing actually special about this name,
aside from the ``bbb`` part: I just named it this way to be consistent with the
conventions that already existed for read-only data.

The table entry itself contains a pointer to the location of the descriptor
(ostensibly in flash), its length, and the ``wValue``/``wIndex`` parameters
that will be passed during ``GET_DESCRIPTOR`` when this descriptor is
requested. The descriptor size is determined by examining the members declared
by ``DescriptorSize``: ``Size`` and ``ExtendedSize``. The ``wValue`` and
``wIndex`` are determined by examining a member of the passed descriptor which
should be named ``tag`` and another which should be called ``kType``. For
``kType``, this is simply a static constant with the descriptor type and can be
seen in the earlier examples in this article. The tag member is used as a
metadata member of the descriptor as described in the previous section. The
struct is very straightforward and simply supplies the index of the descriptor
(``index``, part of ``wValue``) and the language ID, if applicable
(``wIndex``). 

.. code-block:: c++

    // As descriptors declare an explicit size for USB, extra data at the end of
    // the struct is fine. It wastes some space, but not too much. Note that even
    // for the extendable descriptors this is true: we only copy the portion up to
    // Size into the larger-sized descriptor.
    struct __attribute__((packed)) DescriptorTag {
      // Index of this descriptor, if applicable
      uint8_t index;
      // wIndex value for this descriptor
      uint16_t wIndex;

      constexpr DescriptorTag() : index(0), wIndex(0) {}
      constexpr DescriptorTag(uint8_t index, uint16_t wIndex = 0)
          : index(index), wIndex(wIndex) {}
    };

    ...

    // Device Descriptor
    struct __attribute__((packed)) DeviceDescriptor : public DescriptorSize<18> {
      static constexpr uint8_t kType = 1;
      uint8_t bLength;
      uint8_t bDescriptorType = kType;
      ...

      DescriptorTag tag;

      constexpr DeviceDescriptor(uint8_t index = 0) : bLength(Size()), tag(index) {}
      ...
    };

The next piece of this is a change to my `linker script
<https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_node/ld_6.html#SEC6>`_. I
added a ``.rodata.keep`` definition within the flash segment:

.. code-block::
   
    ...
    /* Section Definitions */
    SECTIONS
    {
        .text :
        {
            . = ALIGN(4);
            _sfixed = .;
            KEEP(*(.vectors .vectors.*))
            *(.text .text.* .gnu.linkonce.t.*)
            *(.glue_7t) *(.glue_7)
            KEEP(*(.rodata.keep SORT(.rodata.keep.*))) // <-- New section!
            *(.rodata .rodata* .gnu.linkonce.r.*)
            *(.ARM.extab* .gnu.linkonce.armextab.*)
   ...

There are two important pieces here:

``KEEP``
  The ``KEEP`` statement ensures that the sections placed there do not get
  pruned. I typically have ``-Wl,--gc-sections`` in my linker invocation which
  will prune sections that don't have a reference. This prevents that from
  occurring with these entries.

``SORT``
  Sections names can be referenced with a glob-like syntax using ``*``. By
  putting ``SORT(.rodata.keep.*)`` I am specifying that sections which start
  with ``.rodata.keep.`` should be sorted alphabetically.

The last part to creating my table is the definition of some additional symbols
in C++ source:

.. code-block:: c++

    // This should go at the start of the usb descriptors
    static const __attribute__((used, section(".rodata.keep.usbdescaaa"))) _DescriptorTableEntry _desc_begin;
    static const __attribute__((used, section(".rodata.keep.usbdesczzz"))) _DescriptorTableEntry _desc_end;

Because of ``SORT``, these two variables will be placed before and after the
descriptors defined with the ``USB_DESCRIPTOR`` macro. When the program is
compiled, I end up with a structure that starts with ``_desc_begin``, has
all the program descriptors, and then stops with ``_desc_end``:

.. code-block::

    000013e0 <_ZL11_desc_begin>:
        ...

    000013ec <_ZL20kHidInLedReportEntry>:
        13ec:	0000150d 	andeq	r1, r0, sp, lsl #10
        13f0:	00000019 	andeq	r0, r0, r9, lsl r0
        13f4:	00002200 	andeq	r2, r0, r0, lsl #4

    000013f8 <_ZL17kProductNameEntry>:
        13f8:	0000152c 	andeq	r1, r0, ip, lsr #10
        13fc:	00000026 	andeq	r0, r0, r6, lsr #32
        1400:	04090302 	streq	r0, [r9], #-770	@ 0xfffffcfe

    00001404 <_ZL22kManufacturerNameEntry>:
        1404:	00001555 	andeq	r1, r0, r5, asr r5
        1408:	00000020 	andeq	r0, r0, r0, lsr #32
        140c:	04090301 	streq	r0, [r9], #-769	@ 0xfffffcff

    00001410 <_ZL15kLanguagesEntry>:
        1410:	00001578 	andeq	r1, r0, r8, ror r5
        1414:	00000004 	andeq	r0, r0, r4
        1418:	00000300 	andeq	r0, r0, r0, lsl #6

    0000141c <_ZL22kConfigDescriptorEntry>:
        141c:	000014e1 	andeq	r1, r0, r1, ror #9
        1420:	00000029 	andeq	r0, r0, r9, lsr #32
        1424:	00000200 	andeq	r0, r0, r0, lsl #4

    00001428 <_ZL22kDeviceDescriptorEntry>:
        1428:	000014cc 	andeq	r1, r0, ip, asr #9
        142c:	00000012 	andeq	r0, r0, r2, lsl r0
        1430:	00000100 	andeq	r0, r0, r0, lsl #2

    00001434 <_ZL9_desc_end>:
        ...

This is a little wasteful, since the table entry is 12 bytes and both the begin
and end entries are just null "markers", but it didn't require anything
specific to the USB descriptor table in my linker script to work: The same
pattern here where I name the sections such that ``SORT`` controls the order
they appear in the flash can be used for other such table-like things.

With this table, I can now use a straightforward search to locate descriptors
on demand:

.. code-block:: c++

    bool _DescriptorTableEntry::Find(uint16_t wValue, uint16_t wIndex, const void* &ptr, size_t &length) {
      const _DescriptorTableEntry* entry = &_desc_begin;
      while (entry < &_desc_end) {
        if (entry->wValue == wValue && entry->wIndex == wIndex) {
          ptr = entry->ptr;
          length = entry->length;
          return true;
        }
        ++entry;
      }
      return false;
    }

################################################################################
Descriptor Examples
################################################################################

Some of this is revealed above already, but I figured having some actual
examples of the API used to define the descriptors followed by an example of
those descriptors might be useful.

**********************************************************************
Extendable Descriptors (Configuration/Interface/Endpoint)
**********************************************************************

These descriptors I ended up defining with 3 separate definitions:

* The base data
* The API
* The top-level descriptor that marries the base data, API, and extendable
  descriptor.

I'll use the configuration descriptor as an example here. The data is declared
as noted earlier:

.. code-block:: c++

    struct __attribute__((packed)) ConfigurationDescriptorData
        : public DescriptorSize<9> {
      static constexpr uint8_t kType = 2;
      uint8_t bLength;
      uint8_t bDescriptorType = kType;
      uint16_t wTotalLength = 0;
      uint8_t bNumInterfaces = 0;
      uint8_t bConfigurationValue = 0;
      uint8_t iConfiguration = 0;
      uint8_t bmAttributes = 0;
      uint8_t bMaxPower = 0;

      constexpr ConfigurationDescriptorData()
          : bLength(Size()), wTotalLength(Size()) {}
    };

The API portion of this uses a "fluent" or "builder" style, where ``*this`` is
returned from each method. This allows "chaining" the descriptor. I probably
could have included this API in the top-level class, but keeping it as a
separate class didn't really seem to harm anything. One complication of having
it as a separate class is that it needs to be sure to return instances of the
top-level class in the fluent API methods. This is accomplished using `CRTP
<https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern>`_.

.. code-block:: c++

    template <typename T>
    struct __attribute__((packed)) ConfigurationDescriptorApi {
      constexpr T ConfigurationValue(uint8_t v) {
        auto me = static_cast<T*>(this);
        me->bConfigurationValue = v;
        return *me;
      }

      constexpr T Attributes(uint8_t a) {
        auto me = static_cast<T*>(this);
        me->bmAttributes = a;
        return *me;
      }

      constexpr T MaxPower(uint8_t p) {
        auto me = static_cast<T*>(this);
        me->bMaxPower = p;
        return *me;
      }
    };

Again, I'm not a C++ expert and the above probably could have been done more
succinctly and probably more simply if I just included these methods in the
top-level class.

The top-level class marries together all of these classes into a unified
top-level. This provides the constructor (which you'll notice does require
an index to be passed, since devices have multiple configurations) and the
``WithInterface`` method which permits extending the descriptor. A default
argument to the ``N`` parameter which defines the extended size is provided
to cut down on the verbosity when this is actually used.

.. code-block:: c++

    template <size_t N = 0>
    class __attribute__((packed)) ConfigurationDescriptor
        : public ExtendableDescriptor<N, ConfigurationDescriptorData>,
          public ConfigurationDescriptorApi<ConfigurationDescriptor<N>> {
      using Base = ExtendableDescriptor<N, ConfigurationDescriptorData>;

     public:
      // Constructor for an empty configuration. Configurations require an index.
      constexpr ConfigurationDescriptor(uint8_t index) : Base(index) {}

      template <size_t M, typename T>
      constexpr ConfigurationDescriptor(const ConfigurationDescriptor<M>& other,
                                        T t)
          : Base(other, t) {}

      // Adds an interface
      template <typename T>
      constexpr auto WithInterface(T t) {
        auto other = ConfigurationDescriptor<T::Size() + T::ExtendedSize() +
                                             Base::ExtendedSize()>(*this, t);
        other.wTotalLength =
            decltype(other)::Size() + decltype(other)::ExtendedSize();
        other.bNumInterfaces += 1;
        return other;
      }
    };

One thing to note here is that the ``WithInterface`` method doesn't actually
enforce that the object itself is an interface, it just assumes. Maybe that
could be improved one day, but for flexibility's sake I left it as-is.

The interface and endpoint descriptors are eerily similar to this one in their
structure.

**********************************************************************
String Descriptors
**********************************************************************

String descriptors were a little tricky. I wanted to be able to have an API
like ``StringDescriptor("My String", kMyIndex, kMyLanguage)``. The complication
is that USB represents its characters as 16-bit wide characters. What is most
unfortunate is that on Linux, the ``wchar_t`` "wide char" type is actually 4
bytes long, so it's not suitable for this usage. I ended up compromising by
using ``char16_t`` which represents a UTF-16 code unit. If I actually used
non-ASCII characters I'd probably run into a problem, but so long as I stick to
ASCII this shouldn't cause unexpected string values.

The other difficulty is with appropriately sizing the descriptor for a passed
literal string. It turns out that if I receive the string as a reference to an
array of ``char16_t`` and use a function to construct the descriptor (rather
than just calling the constructor), the template arguments can be deduced.

.. code-block:: c++

    // String Descriptor
    template <size_t N>
    struct __attribute__((packed)) StringDescriptorBase
        : public DescriptorSize<N * 2> {
      static constexpr uint8_t kType = 3;
      uint8_t bLength;
      uint8_t bDescriptorType = kType;
      char16_t data[N - 1];

      DescriptorTag tag;

      constexpr StringDescriptorBase(const char16_t (&data)[N], uint8_t index,
                                     uint16_t wIndex = 0)
          : bLength(N * 2), tag(index, wIndex) {
        for (size_t i = 0; i < N - 1; i++) {
          this->data[i] = data[i];
        }
      }
    };

    // Deduce how large a string descriptor we need based on a literal
    template <size_t N>
    consteval StringDescriptorBase<N> StringDescriptor(const char16_t (&data)[N],
                                                       uint8_t index,
                                                       uint16_t wIndex = 0) {
      return StringDescriptorBase<N>(data, index, wIndex);
    }

The resulting syntax is awfully close to what I had wanted:

.. code-block:: c++

    constexpr auto kLanguage = 0x0409;
    constexpr auto kLanguages = usb::StringDescriptor({kLanguage, 0x0}, 0);
    constexpr auto kManufacturerName =
        usb::StringDescriptor(u"kevincuzner.com", 1, kLanguage);

    USB_DESCRIPTOR(kLanguages);
    USB_DESCRIPTOR(kManufacturerName);

**********************************************************************
HID Report Descriptors
**********************************************************************

HID Report Descriptors are a little different from other descriptors in that
they don't have a defined length. Instead, they're parsed! They are defined in
terms of "items". There are "short" items which are 1-4 bytes in length and
"long" items which can be up to 258 bytes. I tend to only use short items, so
what I ended up doing was defining the descriptor to be just an expandable
descriptor which is expanded item-by-item. The item itself is defined as
something that implements ``DescriptorSize``. Constructors and convenience
functions are provided for constructing the item from an array of bytes:

.. code-block:: c++

    enum class HidItemType {
      kMain = 0,
      kGlobal = 1,
      kLocal = 2,
    };

    // This is a base type which declares one required byte of a short item
    template <size_t N>
    struct __attribute__((packed)) ShortItemBase : public DescriptorSize<N + 1> {
      uint8_t bSize : 2 = 0;
      uint8_t bType : 2;
      uint8_t bTag : 4;
      std::array<uint8_t, N> data;

      static_assert(N <= 4, "ShortItem data must be <= 4 bytes");
      static_assert(N != 3, "ShortItem data must be 0, 1, 2, or 4 bytes");

      constexpr ShortItemBase(HidItemType bType, uint8_t bTag)
          : bType(static_cast<uint8_t>(bType)), bTag(bTag) {}
      constexpr ShortItemBase(HidItemType bType, uint8_t bTag,
                              const uint8_t (&data)[N])
          : bType(static_cast<uint8_t>(bType)), bTag(bTag) {
        bSize = N == 0 ? 0 : N == 1 ? 1 : N == 2 ? 2 : 3;
        std::copy(data, data + N, this->data.begin());
      }
    };

    // Convenience function for constructing short items with data of some length
    template <size_t N>
    constexpr auto ShortItem(HidItemType bType, uint8_t bTag,
                             const uint8_t (&data)[N]) {
      return ShortItemBase<N>(bType, bTag, data);
    }
    constexpr auto ShortItem(HidItemType bType, uint8_t bTag) {
      return ShortItemBase<0>(bType, bTag);
    }

The report descriptor then expands itself short item by short item. I ended up
providing convenience functions for each short item type defined in the
specification (Input, Output, Usage, Collection, End Collection, etc):

.. code-block:: c++

    // The HID report descriptors don't have any extra data before the extendable
    // portion. Declare this untemplated base so we have a kType and a base Size()
    // to call.
    struct __attribute__((packed)) HidReportDescriptorData
        : public DescriptorSize<0> {
      static constexpr uint8_t kType = 0x22;
    };

    // HID report descriptor builder
    template <size_t N = 0>
    class __attribute__((packed)) HidReportDescriptor
        : public ExtendableDescriptor<N, HidReportDescriptorData> {
      using Base = ExtendableDescriptor<N, HidReportDescriptorData>;

     public:
      // This tag is used in the HID descriptor to reference this descriptor
      HidReportDescriptorTag hid_tag;

      constexpr HidReportDescriptor()
          : Base(), hid_tag(Base::Size() + Base::ExtendedSize()) {}
      template <size_t M, typename T>
      constexpr HidReportDescriptor(const HidReportDescriptor<M>& other, T t)
          : Base(other, t), hid_tag(Base::Size() + Base::ExtendedSize()) {}

      // Adds a short item
      constexpr auto ShortItem(HidItemType bType, uint8_t bTag) {
        return HidReportDescriptor<N + 1>(*this,
                                          ::usb::hid::ShortItem(bType, bTag));
      }
      constexpr auto ShortItem(HidItemType bType, uint8_t bTag, uint8_t data0) {
        return HidReportDescriptor<N + 2>(
            *this, ::usb::hid::ShortItem(bType, bTag, {data0}));
      }
      constexpr auto ShortItem(HidItemType bType, uint8_t bTag, uint8_t data0,
                               uint8_t data1) {
        return HidReportDescriptor<N + 3>(
            *this, ::usb::hid::ShortItem(bType, bTag, {data0, data1}));
      }
      constexpr auto ShortItem(HidItemType bType, uint8_t bTag, uint8_t data0,
                               uint8_t data1, uint8_t data2, uint8_t data3) {
        return HidReportDescriptor<N + 5>(
            *this,
            ::usb::hid::ShortItem(bType, bTag, {data0, data1, data2, data3}));
      }

      // Main Items
      constexpr auto Input(uint8_t lsb_flags) {
        return ShortItem(HidItemType::kMain, 0x8, lsb_flags);
      }
      constexpr auto Input(uint8_t lsb_flags, uint8_t msb_flags) {
        return ShortItem(HidItemType::kMain, 0x8, lsb_flags, msb_flags);
      }
      constexpr auto Output(uint8_t lsb_flags) {
        return ShortItem(HidItemType::kMain, 0x9, lsb_flags);
      }
      constexpr auto Output(uint8_t lsb_flags, uint8_t msb_flags) {
        return ShortItem(HidItemType::kMain, 0x9, lsb_flags, msb_flags);
      }
      ...
    };

This allows for what I think is a pretty convenient API for defining a report
descriptor. Here's a before/after comparison between my XML comment method
(which used a macro) and this new method:

.. code-block:: c++

    // Before
    /*
     * <descriptor id="hid_report" childof="hid" top="top" type="0x22" order="1" wIndexType="0x04">
     *  <hidden name="bDescriptorType" size="1">0x22</hidden>
     *  <hidden name="wLength" size="2">sizeof(hid_report)</hidden>
     *  <raw>
     *  HID_SHORT(0x04, 0x00, 0xFF), //USAGE_PAGE (Vendor Defined)
     *  HID_SHORT(0x08, 0x01), //USAGE (Vendor 1)
     *  HID_SHORT(0xa0, 0x01), //COLLECTION (Application)
     *  HID_SHORT(0x08, 0x01), //  USAGE (Vendor 1)
     *  HID_SHORT(0x14, 0x00), //  LOGICAL_MINIMUM (0)
     *  HID_SHORT(0x24, 0xFF, 0x00), //LOGICAL_MAXIMUM (0x00FF)
     *  HID_SHORT(0x74, 0x08), //  REPORT_SIZE (8)
     *  HID_SHORT(0x94, 64), //  REPORT_COUNT(64)
     *  HID_SHORT(0x80, 0x02), //  INPUT (Data, Var, Abs)
     *  HID_SHORT(0x08, 0x01), //  USAGE (Vendor 1)
     *  HID_SHORT(0x90, 0x02), //  OUTPUT (Data, Var, Abs)
     *  HID_SHORT(0xc0),       //END_COLLECTION
     *  </raw>
     * </descriptor>
     */

    // After
    constexpr auto kHidInReport = usb::hid::HidReportDescriptor()
                                      .UsagePage16(0xFF00)  // Vendor
                                      .Usage(0x1)           // Vendor 1
                                      .Collection(0x1)      // Application
                                      .Usage(0x1)           // Vendor 1
                                      .LogicalMin8(0)
                                      .LogicalMax16(0xFF)
                                      .ReportSize8(8)
                                      .ReportCount8(64)
                                      .Input(0x2)   // Data, var, abs
                                      .Usage(0x1)   // Vendor 1
                                      .Output(0x2)  // Data, var, abs
                                      .EndCollection();

I, for one, find that to be much more descriptive and maintainable.

################################################################################
Conclusion
################################################################################

Defining USB descriptors and other constant data using constexpr is a
maintainable and expressive way to include constant data in programs. Even
complex structures can be defined this way. In contrast to my prior
incarnations of this which used a code generator, the use of the C++ language
itself eliminates the need for defining what effectively ends up being a
domain-specific language or at a minimum some kind of extract-transform-load
framework when writing a code generator. Nearly all the effort expended is
entirely spent defining the API to structure data, rather than in the
infrastructure behind that API.
